"""
```julia
vectorized_solve(probs, prob::Union{ODEProblem, SDEProblem}alg;
    dt, saveat = nothing,
    save_everystep = true,
    debug = false, callback = CallbackSet(nothing), tstops = nothing)
```

A lower level interface to the kernel generation solvers of EnsembleGPUKernel with fixed
time-stepping.

## Arguments

  - `probs`: the GPU-setup problems generated by the ensemble.
  - `prob`: the quintessential problem form. Can be just `probs[1]`
  - `alg`: the kernel-based differential equation solver. Must be one of the
    EnsembleGPUKernel specialized methods.

## Keyword Arguments

Only a subset of the common solver arguments are supported.
"""
function vectorized_solve end

function vectorized_solve(probs, prob::ODEProblem, alg;
        dt, saveat = nothing,
        save_everystep = true,
        debug = false, callback = CallbackSet(nothing), tstops = nothing,
        kwargs...)
    backend = get_backend(probs)
    backend = maybe_prefer_blocks(backend)
    # if saveat is specified, we'll use a vector of timestamps.
    # otherwise it's a matrix that may be different for each ODE.
    timeseries = prob.tspan[1]:dt:prob.tspan[2]
    nsteps = length(timeseries)

    prob = convert(ImmutableODEProblem, prob)
    dt = convert(eltype(prob.tspan), dt)

    if saveat === nothing
        if save_everystep
            len = length(prob.tspan[1]:dt:prob.tspan[2])
            if tstops !== nothing
                len += length(tstops) - count(x -> x in tstops, timeseries)
                nsteps += length(tstops) - count(x -> x in tstops, timeseries)
            end
        else
            len = 2
        end
        ts = allocate(backend, typeof(dt), (len, length(probs)))
        fill!(ts, prob.tspan[1])
        us = allocate(backend, typeof(prob.u0), (len, length(probs)))
    else
        # Get the time type from the problem
        Tt = eltype(prob.tspan)
        
        # FIX for Issue #379: Convert saveat to proper type
        saveat_converted = if saveat isa AbstractRange
            Tt.(collect(range(Tt(first(saveat)), Tt(last(saveat)), length = length(saveat))))
        elseif saveat isa AbstractVector
            Tt.(collect(saveat))
        else
            # saveat is a Number (step size)
            t0, tf = Tt.(prob.tspan)
            if Tt(saveat) == Tt(0.0)
                Tt.([t0, tf])
            else
                num_points = Int(ceil(abs(tf - t0) / abs(Tt(saveat)))) + 1
                Tt.(collect(range(t0, tf, length = num_points)))
            end
        end
        
        saveat_converted = adapt(backend, saveat_converted)
        
        ts = allocate(backend, typeof(dt), (length(saveat_converted), length(probs)))
        fill!(ts, prob.tspan[1])
        us = allocate(backend, typeof(prob.u0), (length(saveat_converted), length(probs)))
    end

    tstops = adapt(backend, tstops)

    kernel = ode_solve_kernel(backend)

    if backend isa CPU
        @warn "Running the kernel on CPU"
    end

    kernel(probs, alg, us, ts, dt, callback, tstops, nsteps, saveat_converted,
        Val(save_everystep);
        ndrange = length(probs))

    # we build the actual solution object on the CPU because the GPU would create one
    # containig CuDeviceArrays, which we cannot use on the host (not GC tracked,
    # no useful operations, etc). That's unfortunate though, since this loop is
    # generally slower than the entire GPU execution, and necessitates synchronization
    #EDIT: Done when using with DiffEqGPU
    ts, us
end

# SDEProblems over GPU cannot support u0 as a Number type, because GPU kernels compiled only through u0 being StaticArrays
function vectorized_solve(probs, prob::SDEProblem, alg;
        dt, saveat = nothing,
        save_everystep = true,
        debug = false,
        kwargs...)
    backend = get_backend(probs)
    backend = maybe_prefer_blocks(backend)

    dt = convert(eltype(prob.tspan), dt)

    if saveat === nothing
        if save_everystep
            len = length(prob.tspan[1]:dt:prob.tspan[2])
        else
            len = 2
        end
        ts = allocate(backend, typeof(dt), (len, length(probs)))
        fill!(ts, prob.tspan[1])
        us = allocate(backend, typeof(prob.u0), (len, length(probs)))
    else
        # Get the time type from the problem
        Tt = eltype(prob.tspan)
        
        # FIX for Issue #379: Convert saveat to proper type
        saveat_converted = if saveat isa AbstractRange
            Tt.(collect(range(Tt(first(saveat)), Tt(last(saveat)), length = length(saveat))))
        elseif saveat isa AbstractVector
            Tt.(collect(saveat))
        else
            # saveat is a Number (step size)
            t0, tf = Tt.(prob.tspan)
            if Tt(saveat) == Tt(0.0)
                Tt.([t0, tf])
            else
                num_points = Int(ceil(abs(tf - t0) / abs(Tt(saveat)))) + 1
                Tt.(collect(range(t0, tf, length = num_points)))
            end
        end
        
        ts = allocate(backend, typeof(dt), (length(saveat_converted), length(probs)))
        fill!(ts, prob.tspan[1])
        us = allocate(backend, typeof(prob.u0), (length(saveat_converted), length(probs)))
    end

    if alg isa GPUEM
        kernel = em_kernel(backend)
    elseif alg isa Union{GPUSIEA}
        SciMLBase.is_diagonal_noise(prob) ? nothing :
        error("The algorithm is not compatible with the chosen noise type. Please see the documentation on the solver methods")
        kernel = siea_kernel(backend)
    end

    if backend isa CPU
        @warn "Running the kernel on CPU"
    end

    kernel(probs, us, ts, dt, saveat_converted, Val(save_everystep);
        ndrange = length(probs))
    ts, us
end

"""
```julia
vectorized_asolve(probs, prob::ODEProblem, alg;
    dt = 0.1f0, saveat = nothing,
    save_everystep = false,
    abstol = 1.0f-6, reltol = 1.0f-3,
    callback = CallbackSet(nothing), tstops = nothing)
```

A lower level interface to the kernel generation solvers of EnsembleGPUKernel with adaptive
time-stepping.

## Arguments

  - `probs`: the GPU-setup problems generated by the ensemble.
  - `prob`: the quintessential problem form. Can be just `probs[1]`
  - `alg`: the kernel-based differential equation solver. Must be one of the
    EnsembleGPUKernel specialized methods.

## Keyword Arguments

Only a subset of the common solver arguments are supported.
"""
function vectorized_asolve end

function vectorized_asolve(probs, prob::ODEProblem, alg;
        dt = 0.1f0, saveat = nothing,
        save_everystep = false,
        abstol = 1.0f-6, reltol = 1.0f-3,
        debug = false, callback = CallbackSet(nothing), tstops = nothing,
        kwargs...)
    
    backend = get_backend(probs)
    backend = maybe_prefer_blocks(backend)

    # Get the time type from the problem
    Tt = eltype(prob.tspan)
    
    # FIX for Issue #379: Convert saveat to eliminate 
    # StepRangeLen's internal Float64 fields which crash Metal

    if saveat !== nothing
        if saveat isa Number
            # Handle edge case: saveat = 0.0 means only save endpoints
            if Tt(saveat) == Tt(0.0)
                saveat_converted = Tt.([prob.tspan[1], prob.tspan[2]])
            else
                # Create proper range with correct type
                t0, tf = Tt.(prob.tspan)
                
                # Handle both forward and reverse time integration
                num_points = Int(ceil(abs(tf - t0) / abs(Tt(saveat)))) + 1
                
                # Safety check: prevent massive arrays
                max_saveat_length = 100_000
                if num_points > max_saveat_length
                    error("saveat would create too many save points ($num_points). " *
                          "Consider using a larger saveat value.")
                end
                
                # Create range and convert to pure Vector{Tt}
                saveat_range = range(t0, tf, length = num_points)
                saveat_converted = Tt.(collect(saveat_range))
            end
        elseif saveat isa AbstractRange || saveat isa AbstractArray
            # Range or array - convert all elements to Tt
            # This eliminates StepRangeLen's Float64 internals
            saveat_converted = Tt.(collect(saveat))
        else
            # Already in correct form
            saveat_converted = saveat
        end
    else
        saveat_converted = nothing
    end

    prob = convert(ImmutableODEProblem, prob)
    dt = convert(eltype(prob.tspan), dt)

    if saveat_converted === nothing
        if save_everystep
            len = ceil(Int, (prob.tspan[2] - prob.tspan[1]) / dt) + 1
        else
            len = 2
        end
        ts = allocate(backend, typeof(dt), (len, length(probs)))
        fill!(ts, prob.tspan[1])
        us = allocate(backend, typeof(prob.u0), (len, length(probs)))
    else
        ts = allocate(backend, typeof(dt), (length(saveat_converted), length(probs)))
        fill!(ts, prob.tspan[1])
        us = allocate(backend, typeof(prob.u0), (length(saveat_converted), length(probs)))
    end

    us = adapt(backend, us)
    ts = adapt(backend, ts)
    tstops = adapt(backend, tstops)

    kernel = ode_asolve_kernel(backend)

    if backend isa CPU
        @warn "Running the kernel on CPU"
    end

    kernel(probs, alg, us, ts, dt, callback, tstops,
        abstol, reltol, saveat_converted, Val(save_everystep);
        ndrange = length(probs))

    ts, us
end

function vectorized_asolve(probs, prob::SDEProblem, alg;
        dt, saveat = nothing,
        save_everystep = true,
        debug = false,
        kwargs...)
    error("Adaptive time-stepping is not supported yet with GPUEM.")
end
