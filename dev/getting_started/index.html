<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started with GPU-Accelerated Differential Equations in Julia · DiffEqGPU.jl</title><meta name="title" content="Getting Started with GPU-Accelerated Differential Equations in Julia · DiffEqGPU.jl"/><meta property="og:title" content="Getting Started with GPU-Accelerated Differential Equations in Julia · DiffEqGPU.jl"/><meta property="twitter:title" content="Getting Started with GPU-Accelerated Differential Equations in Julia · DiffEqGPU.jl"/><meta name="description" content="Documentation for DiffEqGPU.jl."/><meta property="og:description" content="Documentation for DiffEqGPU.jl."/><meta property="twitter:description" content="Documentation for DiffEqGPU.jl."/><meta property="og:url" content="https://docs.sciml.ai/DiffEqGPU/stable/getting_started/"/><meta property="twitter:url" content="https://docs.sciml.ai/DiffEqGPU/stable/getting_started/"/><link rel="canonical" href="https://docs.sciml.ai/DiffEqGPU/stable/getting_started/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DiffEqGPU.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">DiffEqGPU.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">DiffEqGPU: Massively Data-Parallel GPU Solving of ODEs</a></li><li class="is-active"><a class="tocitem" href>Getting Started with GPU-Accelerated Differential Equations in Julia</a><ul class="internal"><li><a class="tocitem" href="#The-two-ways-to-accelerate-ODE-solvers-with-GPUs"><span>The two ways to accelerate ODE solvers with GPUs</span></a></li><li><a class="tocitem" href="#Supported-GPUs"><span>Supported GPUs</span></a></li><li><a class="tocitem" href="#Simple-Example-of-Within-Method-GPU-Parallelism"><span>Simple Example of Within-Method GPU Parallelism</span></a></li><li><a class="tocitem" href="#Example-of-Parameter-Parallelism-with-GPU-Ensemble-Methods"><span>Example of Parameter-Parallelism with GPU Ensemble Methods</span></a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">GPU Ensembles</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/gpu_ensemble_basic/">Massively Data-Parallel ODE Solving the Lorenz Equation</a></li><li><a class="tocitem" href="../tutorials/parallel_callbacks/">Massively Parallel ODE Solving with Event Handling and Callbacks</a></li><li><a class="tocitem" href="../tutorials/multigpu/">Setting Up Multi-GPU Parallel Parameter Sweeps</a></li><li><a class="tocitem" href="../tutorials/lower_level_api/">Using the Lower Level API for Decreased Overhead with GPU acclerated Ensembles</a></li><li><a class="tocitem" href="../tutorials/weak_order_conv_sde/">Using the EnsembleGPUKernel SDE solvers for the expectation of SDEs </a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Within-Method GPU</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../tutorials/within_method_gpu/">Within-Method GPU Parallelism of Ordinary Differential Equation Solves</a></li></ul></li></ul></li><li><span class="tocitem">Examples</span><ul><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">GPU Ensembles</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/sde/">GPU Parallel Solving of Stochastic Differential Equations</a></li><li><a class="tocitem" href="../examples/ad/">Using GPU-accelerated Ensembles with Automatic Differentiation</a></li><li><a class="tocitem" href="../examples/reductions/">Batched Reductions for Lowering Peak Memory Requirements</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Within-Method GPU</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../examples/reaction_diffusion/">GPU-Accelerated Stochastic Partial Differential Equations</a></li><li><a class="tocitem" href="../examples/bruss/">GPU-Acceleration of a Stiff Nonlinear Partial Differential Equation</a></li></ul></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../manual/ensemblegpukernel/">EnsembleGPUKernel</a></li><li><a class="tocitem" href="../manual/ensemblegpuarray/">EnsembleGPUArray</a></li><li><a class="tocitem" href="../manual/backends/">Compute Backends (GPU Choices)</a></li><li><a class="tocitem" href="../manual/optimal_trajectories/">Choosing Optimal Numbers of Trajectories</a></li><li><a class="tocitem" href="../manual/choosing_ensembler/">Choosing the Ensemble: EnsembleGPUArray vs EnsembleGPUKernel</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Getting Started with GPU-Accelerated Differential Equations in Julia</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting Started with GPU-Accelerated Differential Equations in Julia</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/DiffEqGPU.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/DiffEqGPU.jl/blob/master/docs/src/getting_started.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Getting-Started-with-GPU-Accelerated-Differential-Equations-in-Julia"><a class="docs-heading-anchor" href="#Getting-Started-with-GPU-Accelerated-Differential-Equations-in-Julia">Getting Started with GPU-Accelerated Differential Equations in Julia</a><a id="Getting-Started-with-GPU-Accelerated-Differential-Equations-in-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Getting-Started-with-GPU-Accelerated-Differential-Equations-in-Julia" title="Permalink"></a></h1><h2 id="The-two-ways-to-accelerate-ODE-solvers-with-GPUs"><a class="docs-heading-anchor" href="#The-two-ways-to-accelerate-ODE-solvers-with-GPUs">The two ways to accelerate ODE solvers with GPUs</a><a id="The-two-ways-to-accelerate-ODE-solvers-with-GPUs-1"></a><a class="docs-heading-anchor-permalink" href="#The-two-ways-to-accelerate-ODE-solvers-with-GPUs" title="Permalink"></a></h2><p>There are two very different ways that one can accelerate an ODE solution with GPUs. There is one case where <code>u</code> is very big and <code>f</code> is very expensive but very structured, and you use GPUs to accelerate the computation of said <code>f</code>. The other use case is where <code>u</code> is very small, but you want to solve the ODE <code>f</code> over many different initial conditions (<code>u0</code>) or parameters <code>p</code>. In that case, you can use GPUs to parallelize over different parameters and initial conditions. In other words:</p><table><tr><th style="text-align: left">Type of Problem</th><th style="text-align: left">SciML Solution</th></tr><tr><td style="text-align: left">Accelerate a big ODE</td><td style="text-align: left">Use <a href="https://cuda.juliagpu.org/stable/">CUDA.jl&#39;s</a> CuArray as <code>u0</code></td></tr><tr><td style="text-align: left">Solve the same ODE with many <code>u0</code> and <code>p</code></td><td style="text-align: left">Use <a href="https://docs.sciml.ai/DiffEqGPU/stable/">DiffEqGPU.jl&#39;s</a> <code>EnsembleGPUArray</code> and <code>EnsembleGPUKernel</code></td></tr></table><h2 id="Supported-GPUs"><a class="docs-heading-anchor" href="#Supported-GPUs">Supported GPUs</a><a id="Supported-GPUs-1"></a><a class="docs-heading-anchor-permalink" href="#Supported-GPUs" title="Permalink"></a></h2><p>SciML&#39;s GPU support extends to a wide array of hardware, including:</p><table><tr><th style="text-align: left">GPU Manufacturer</th><th style="text-align: left">GPU Kernel Language</th><th style="text-align: left">Julia Support Package</th><th style="text-align: left">Backend Type</th></tr><tr><td style="text-align: left">NVIDIA</td><td style="text-align: left">CUDA</td><td style="text-align: left"><a href="https://github.com/JuliaGPU/CUDA.jl">CUDA.jl</a></td><td style="text-align: left"><code>CUDA.CUDABackend()</code></td></tr><tr><td style="text-align: left">AMD</td><td style="text-align: left">ROCm</td><td style="text-align: left"><a href="https://github.com/JuliaGPU/AMDGPU.jl">AMDGPU.jl</a></td><td style="text-align: left"><code>AMDGPU.ROCBackend()</code></td></tr><tr><td style="text-align: left">Intel</td><td style="text-align: left">OneAPI</td><td style="text-align: left"><a href="https://github.com/JuliaGPU/oneAPI.jl">OneAPI.jl</a></td><td style="text-align: left"><code>oneAPI.oneAPIBackend()</code></td></tr><tr><td style="text-align: left">Apple (M-Series)</td><td style="text-align: left">Metal</td><td style="text-align: left"><a href="https://github.com/JuliaGPU/Metal.jl">Metal.jl</a></td><td style="text-align: left"><code>Metal.MetalBackend()</code></td></tr></table><p>For this tutorial we will demonstrate the CUDA backend for NVIDIA GPUs, though any of the other GPUs can be used by simply swapping out the <code>backend</code> choice.</p><h2 id="Simple-Example-of-Within-Method-GPU-Parallelism"><a class="docs-heading-anchor" href="#Simple-Example-of-Within-Method-GPU-Parallelism">Simple Example of Within-Method GPU Parallelism</a><a id="Simple-Example-of-Within-Method-GPU-Parallelism-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-Example-of-Within-Method-GPU-Parallelism" title="Permalink"></a></h2><p>The following is a quick and dirty example of doing within-method GPU parallelism. Let&#39;s say we had a simple but large ODE with many linear algebra or map/broadcast operations:</p><pre><code class="language-julia hljs">using OrdinaryDiffEq, LinearAlgebra
u0 = rand(1000)
A = randn(1000, 1000)
f(du, u, p, t) = mul!(du, A, u)
prob = ODEProblem(f, u0, (0.0, 1.0))
sol = solve(prob, Tsit5())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
Interpolation: specialized 4th order &quot;free&quot; interpolation
t: 48-element Vector{Float64}:
 0.0
 0.0017460573639805404
 0.006704015767905096
 0.014319370930348364
 0.023221826973707938
 0.03452006705349458
 0.047072496799016324
 0.06120788819832835
 0.07600328352138182
 0.089887496749854
 ⋮
 0.7933992236269642
 0.8197223678987577
 0.8468102324990433
 0.8741066512525104
 0.9015907020769398
 0.9293423676815272
 0.9568614932626144
 0.9849342135770022
 1.0
u: 48-element Vector{Vector{Float64}}:
 [0.5025392443576809, 0.7591172646546439, 0.22581999791596086, 0.23102511372775658, 0.28051354669381123, 0.49886392696305615, 0.7902067268986426, 0.5064156793039125, 0.7769744394158119, 0.6616782645815115  …  0.8212806189354621, 0.34218927845101166, 0.6878901347084793, 0.9579856348748483, 0.6211972180515419, 0.7639676982658415, 0.31628844071954754, 0.008899371025192448, 0.46213995402621977, 0.9946262761664695]
 [0.564509883357797, 0.7323700526112732, 0.17317718548104769, 0.21316156484125093, 0.30359203082566916, 0.5083819860821849, 0.8197235509826144, 0.57026720445949, 0.7277738544472674, 0.6686384886639892  …  0.8493064172033837, 0.37495162218621025, 0.7242981415458869, 1.011685288698082, 0.6383594322374649, 0.7744666210738418, 0.33935613500492967, 0.024315829040908843, 0.4932119825582928, 0.9955902356477314]
 [0.7541481022654971, 0.6512991048643804, 0.02196229509332479, 0.15887703224068625, 0.37467768944864016, 0.5410176874844858, 0.8969276969719753, 0.7574584782219329, 0.5882924222918493, 0.6856686837072739  …  0.9194937429080167, 0.4767556986985899, 0.8092167816226892, 1.1599492514781282, 0.694783908676237, 0.8036408434761888, 0.40836039385463724, 0.06717706588927172, 0.5776322627058214, 1.0002753945135938]
 [1.0922379684607104, 0.5137629605176164, -0.21381615632681272, 0.0663987914762576, 0.5011444648567268, 0.6033005580667361, 0.9973567397449704, 1.0538359199783025, 0.37449640931501377, 0.707425514557546  …  0.997498611077629, 0.65503096235981, 0.8841451033712505, 1.3750451804886987, 0.8010845873486654, 0.8483206690281013, 0.5288941814218894, 0.13705487464098698, 0.6951799851918488, 1.0156855790093269]
 [1.576251954723386, 0.33600059667383125, -0.49191454577956945, -0.05381712488523661, 0.6788115002443611, 0.6871061985447604, 1.0899982866955071, 1.397223228117366, 0.12562787038798076, 0.7344316919146228  …  1.034314371464989, 0.8888219939952531, 0.8785289602512726, 1.6071207297944032, 0.9510145047413581, 0.9028321835852599, 0.7023248969086583, 0.24284674075000792, 0.8128518087275947, 1.0482503153365612]
 [2.3607917349559013, 0.08793434432688176, -0.8449900324260948, -0.2237474569462749, 0.956820729109876, 0.8027559566786635, 1.177978281451744, 1.8023816719217711, -0.1857485550645876, 0.786255817704967  …  0.9728960455123183, 1.207867641519857, 0.7043991685543584, 1.875029125516842, 1.1777828895145017, 0.9739983438404504, 0.9924538060488919, 0.45722066298508784, 0.934137143259855, 1.1034294834944995]
 [3.501673539048462, -0.2130065599251324, -1.2385730596401328, -0.4365220556429444, 1.3401119881012817, 0.9535648783964389, 1.2546565628829718, 2.192541244873288, -0.5182069235755918, 0.8797695821408044  …  0.7135814834354494, 1.5675537575304153, 0.24846588262688793, 2.1498134051066455, 1.4892675234061596, 1.0345767239889274, 1.4334977036880379, 0.8777146209987329, 1.046426333515253, 1.1425580119251453]
 [5.185097440554946, -0.5757562130063147, -1.7043320423672532, -0.7093810824467112, 1.8591886279494372, 1.2170651086290019, 1.347020814193673, 2.574324832100407, -0.8594979722687179, 1.0147287862096628  …  0.08536212518328452, 1.9569708720943038, -0.666176367431668, 2.460041000005208, 1.9774583448721346, 1.0047647314783612, 2.111403625379449, 1.7084523523706714, 1.1840279831714489, 1.0477938135665312]
 [7.466707443085445, -0.9611615397756959, -2.2869622900177387, -1.0277236566876342, 2.461008052191686, 1.7650093175255916, 1.5020357726315234, 3.0199710395361463, -1.1511751488096054, 1.0924115340274838  …  -1.1137897039068945, 2.3577975802811175, -2.1575503553063085, 2.839963202968425, 2.822838885666709, 0.6928251245881981, 3.0559191893375277, 3.1511287537947084, 1.412931181992034, 0.5694218429546043]
 [10.161228426052084, -1.2884034434014677, -3.058360838138829, -1.3302301274010464, 2.9925600686177787, 2.7800465898945808, 1.7680309688424882, 3.708635338673924, -1.3240279801459596, 0.8978622918646272  …  -2.9597625119608946, 2.8073337537248024, -4.0901582900901605, 3.3191974774594937, 4.260520443614682, -0.10977419147467492, 4.1869292135517355, 5.192303900602119, 1.7892821220496211, -0.5460829197651772]
 ⋮
 [1.0256829602104752e9, -1.4704778171187458e10, 2.1981078680357273e10, 2.728046486510647e9, -3.8965554995474374e8, -1.447749335318877e10, -1.7131897914888692e9, -1.2108769833331736e10, 2.5804771595372605e9, -5.97699062996193e9  …  -6.3871379351066e9, -5.445078947590716e8, -2.921522973439939e8, 4.079739723522224e9, -5.498859550387484e9, 1.6154816763341454e10, 5.317333099678879e9, 1.6617662511216357e8, -1.2345645368450068e10, 4.76169973413564e9]
 [4.102800228867718e9, -3.672326208212151e10, 5.475020216527941e10, 7.658825770985814e9, -3.568405174597912e8, -3.3507812993290367e10, -4.403967181116129e9, -2.7932031998569572e10, 1.1255318337792488e10, -1.368932010490691e10  …  -1.469019166101528e10, 5.438825812180547e8, 5.2277687368099794e7, 9.478729372673061e9, -1.2290473866663568e10, 3.553787290635597e10, 1.1708644285273487e10, 3.8614484768554554e9, -3.0705730148001564e10, 1.0522060960447891e10]
 [1.3817947561808008e10, -9.268165375418817e10, 1.374318502112814e11, 2.129197251163915e10, 2.893515010948268e8, -7.871844055221082e10, -1.125008627634984e10, -6.585869450689052e10, 3.887314551631099e10, -3.1643815858914032e10  …  -3.508144965645493e10, 5.1161846745173235e9, 2.1167713383980234e9, 2.292853905024586e10, -2.764431819782675e10, 7.926522116001724e10, 2.61008683050658e10, 1.7015963406328442e10, -7.828451554089456e10, 2.364893884392461e10]
 [4.1814531729242485e10, -2.3159075568868976e11, 3.4158257755342914e11, 5.823831034337868e10, 2.151007527094165e9, -1.8482018433352823e11, -2.803942897910188e10, -1.562539099308355e11, 1.2000232578767435e11, -7.241206442294312e10  …  -8.541000574853362e10, 1.9145931214671856e10, 1.021046054210689e10, 5.616160875321385e10, -6.183617402799579e10, 1.764915676785289e11, 5.766487277802272e10, 5.753177788272522e10, -2.0003801830525104e11, 5.329923786386776e10]
 [1.1807030295874408e11, -5.724466010987032e11, 8.411136826290669e11, 1.5783594222310684e11, 4.223484204556518e9, -4.343527763900816e11, -6.803826896007854e10, -3.730942814426864e11, 3.484278731822776e11, -1.6400028303083655e11  …  -2.111953234433739e11, 5.600318810721533e10, 3.769308232131422e10, 1.3815807722160416e11, -1.3808755593311215e11, 3.9267825542961346e11, 1.2572563562711305e11, 1.7350685215213593e11, -5.1049532989664526e11, 1.2082969449739177e11]
 [3.1821078552824615e11, -1.4038487030811409e12, 2.0589406535883638e12, 4.265389648797428e11, -4.818921822176788e9, -1.0262488287464955e12, -1.6048572618773578e11, -8.985296712409902e11, 9.773385663041272e11, -3.693573712561595e11  …  -5.295723031233646e11, 1.427346040408889e11, 1.2527870322084915e11, 3.407410802767034e11, -3.0951098295397327e11, 8.767358428484409e11, 2.7023134117407373e11, 4.9236475094975525e11, -1.3018060279495654e12, 2.7742125423667755e11]
 [8.143907851213302e11, -3.3645728488046655e12, 4.934179767290842e12, 1.1304118562051355e12, -7.79314410428256e10, -2.403655411925356e12, -3.601891999221419e11, -2.1458635515041914e12, 2.634991361729227e12, -8.189403146120977e11  …  -1.3187378194069856e12, 3.20881842399273e11, 3.87319585247303e11, 8.277006669560339e11, -6.870660798827722e11, 1.9405241811125571e12, 5.631066653002656e11, 1.3221918087382383e12, -3.2578287557504756e12, 6.38332137001463e11]
 [2.0499222004017097e12, -8.088942837119732e12, 1.1874285664147645e13, 3.0203181172361357e12, -4.241629822214363e11, -5.722892285693561e12, -7.787094205238442e11, -5.201839991722113e12, 7.078973889163777e12, -1.8403714893347397e12  …  -3.3347631946879727e12, 6.449794259977246e11, 1.1785977219893228e12, 2.0318654445400923e12, -1.5436217195965964e12, 4.3659962538970474e12, 1.156780461599673e12, 3.5028536585826396e12, -8.207741292307389e12, 1.5136499834303633e12]
 [3.32305236134565e12, -1.288129659056256e13, 1.8922050548245875e13, 5.093051917195797e12, -9.256290516445881e11, -9.114350883702793e12, -1.1451130313002883e12, -8.353123134099205e12, 1.1936653628706715e13, -2.846825420118581e12  …  -5.473985135947022e12, 8.741497142395105e11, 2.1177029620570251e12, 3.2820481762231885e12, -2.3769978768513574e12, 6.753291397840154e12, 1.6785947135948518e12, 5.846536920707511e12, -1.3411581750173848e13, 2.4217991785766455e12]</code></pre><p>Translating this to a GPU-based solve of the ODE simply requires moving the arrays for the initial condition, parameters, and caches to the GPU. This looks like:</p><pre><code class="language-julia hljs">using OrdinaryDiffEq, CUDA, LinearAlgebra
u0 = cu(rand(1000))
A = cu(randn(1000, 1000))
f(du, u, p, t) = mul!(du, A, u)
prob = ODEProblem(f, u0, (0.0f0, 1.0f0)) # Float32 is better on GPUs!
sol = solve(prob, Tsit5())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
Interpolation: specialized 4th order &quot;free&quot; interpolation
t: 47-element Vector{Float32}:
 0.0
 0.0026315092
 0.0076305955
 0.014856268
 0.023957422
 0.034955107
 0.047603913
 0.061684184
 0.07742522
 0.09273072
 ⋮
 0.7925204
 0.81982714
 0.8483782
 0.8775659
 0.90655315
 0.93570405
 0.96486896
 0.99425656
 1.0
u: 47-element Vector{CUDA.CuArray{Float32, 1, CUDA.Mem.DeviceBuffer}}:
 Float32[0.7225247, 0.6827509, 0.46744737, 0.26545057, 0.04414476, 0.1619979, 0.49150833, 0.16592944, 0.76445055, 0.7400701  …  0.53425467, 0.59935826, 0.60482174, 0.53545636, 0.63642085, 0.045652226, 0.80447304, 0.58318394, 0.26308885, 0.07304496]
 Float32[0.70303774, 0.6500045, 0.46938607, 0.2938062, 0.052414216, 0.18511477, 0.5198097, 0.2251908, 0.7827285, 0.72593164  …  0.53357834, 0.5855796, 0.5951858, 0.5525056, 0.5637058, 0.008294081, 0.82217926, 0.57241875, 0.25514564, 0.120787494]
 Float32[0.65449476, 0.5843905, 0.47518268, 0.34049872, 0.059031248, 0.2386228, 0.5781209, 0.3613446, 0.8345887, 0.696833  …  0.5467951, 0.56020874, 0.5753321, 0.61105466, 0.42069042, -0.036201555, 0.8537953, 0.55060935, 0.24477677, 0.21258187]
 Float32[0.55849123, 0.48954397, 0.49194542, 0.39145717, 0.04425673, 0.33861044, 0.6668797, 0.608908, 0.9501803, 0.6455572  …  0.59690183, 0.52526, 0.540162, 0.75404626, 0.20365262, -0.043062713, 0.89473045, 0.5171586, 0.23878954, 0.34487927]
 Float32[0.39368913, 0.38913816, 0.53427094, 0.4265301, -0.02374488, 0.5021369, 0.7717445, 0.996237, 1.1684444, 0.55456257  …  0.7072019, 0.48530567, 0.47538504, 1.025663, -0.08439971, 0.035023384, 0.93824303, 0.47399336, 0.24483716, 0.5046424]
 Float32[0.1212203, 0.33196568, 0.627032, 0.4188235, -0.19679715, 0.7508257, 0.8610578, 1.5557679, 1.5549736, 0.38067228  …  0.9051922, 0.44912893, 0.34119383, 1.4727477, -0.44742352, 0.23928799, 0.97913486, 0.42191914, 0.27925125, 0.6779353]
 Float32[-0.32172176, 0.40827894, 0.79903436, 0.32075453, -0.5489147, 1.0917214, 0.87011945, 2.2826025, 2.205685, 0.04414882  …  1.2213372, 0.4403709, 0.053891897, 2.1066384, -0.86733884, 0.59514743, 1.0115663, 0.35704634, 0.39089298, 0.8409999]
 Float32[-1.0576835, 0.7440239, 1.0715864, 0.044710785, -1.1769041, 1.513891, 0.7003077, 3.1153433, 3.280873, -0.59731704  …  1.7056223, 0.50319934, -0.54874647, 2.8703952, -1.2914454, 1.116311, 1.0329729, 0.250507, 0.70598805, 0.97881895]
 Float32[-2.3686838, 1.515115, 1.4451475, -0.6041113, -2.222917, 2.0097659, 0.19418256, 3.8930962, 5.1095223, -1.8312967  …  2.478216, 0.7100382, -1.8054675, 3.5927691, -1.5875037, 1.8545676, 1.0488384, -0.0053459853, 1.5245212, 1.1263922]
 Float32[-4.451754, 2.729189, 1.7861743, -1.8237592, -3.6087675, 2.5278747, -0.73530376, 4.1606746, 7.7941113, -3.8415778  …  3.581097, 1.090233, -3.9780135, 3.8316417, -1.44118, 2.8008797, 1.0765508, -0.5999393, 3.1404438, 1.4147009]
 ⋮
 Float32[8.824565f9, -2.2353566f10, -1.2284248f9, 4.5821153f9, -1.3628768f10, -1.3454379f10, -1.5564204f10, -8.894392f9, 4.7344553f9, 1.7011054f10  …  2.564758f10, 8.0708495f9, -8.114939f9, 1.1835382f10, 2.0595294f10, 1.4037524f10, 6.3316064f8, -2.574791f10, 2.6456371f10, -6.8841536f8]
 Float32[1.9375479f10, -5.397361f10, -3.351768f9, 6.6897085f9, -3.193777f10, -3.1437576f10, -3.817595f10, -1.9607966f10, 8.351324f9, 3.7169885f10  …  6.1636473f10, 1.9515163f10, -2.0887106f10, 3.0795528f10, 4.8416838f10, 3.565286f10, 2.3581568f9, -6.16722f10, 6.6675495f10, -9.733023f8]
 Float32[4.3843035f10, -1.3919184f11, -8.715765f9, 7.8203694f9, -7.565009f10, -7.531131f10, -9.722679f10, -4.5324268f10, 1.2755874f10, 8.3999056f10  …  1.5391844f11, 4.858561f10, -5.523795f10, 8.2276745f10, 1.1691341f11, 9.271944f10, 6.8480077f9, -1.5473071f11, 1.7324961f11, -1.07187494f9]
 Float32[1.0177321f11, -3.7435595f11, -2.1628383f10, 3.3732529f9, -1.7744788f11, -1.8204808f11, -2.5172009f11, -1.0774445f11, 1.1898215f10, 1.9447846f11  …  3.912012f11, 1.2198168f11, -1.4674493f11, 2.2150658f11, 2.84229f11, 2.4204686f11, 1.6423894f10, -3.983256f11, 4.546249f11, -8.179858f8]
 Float32[2.3996703f11, -1.01305496f12, -5.0540126f10, -1.7075609f10, -4.0176478f11, -4.3459877f11, -6.438509f11, -2.5632563f11, -1.8193912f10, 4.5436312f11  …  9.845419f11, 3.008135f11, -3.8116187f11, 5.858209f11, 6.782362f11, 6.181776f11, 3.0043122f10, -1.0218094f12, 1.1722572f12, -2.6702508f9]
 Float32[5.8802314f11, -2.771777f12, -1.1320558f11, -7.253592f10, -8.852779f11, -1.0400577f12, -1.6441394f12, -6.15724f11, -1.5709076f11, 1.0914169f12  …  2.4816176f12, 7.3768206f11, -9.820322f11, 1.5448948f12, 1.607414f12, 1.5662078f12, 2.5168226f10, -2.6365442f12, 3.006812f12, -2.4933814f10]
 Float32[1.5009452f12, -7.581524f12, -2.4300241f11, -1.817655f11, -1.881664f12, -2.4934715f12, -4.1653518f12, -1.4849096f12, -6.439183f11, 2.698297f12  …  6.235828f12, 1.7931837f12, -2.5046698f12, 4.0506247f12, 3.7717543f12, 3.9250997f12, -1.1668537f11, -6.793232f12, 7.6353965f12, -1.5674465f11]
 Float32[4.015159f12, -2.078769f13, -5.0495462f11, -3.0769506f11, -3.8434054f12, -6.048011f12, -1.0523076f13, -3.6151765f12, -2.178566f12, 6.9205214f12  …  1.5730337f13, 4.3566521f12, -6.387422f12, 1.0648936f13, 8.833077f12, 9.81156f12, -8.76899f11, -1.755765f13, 1.932217f13, -7.69174f11]
 Float32[4.8864706f12, -2.5295143f13, -5.8036486f11, -3.1657512f11, -4.3901667f12, -7.1977203f12, -1.259647f13, -4.302969f12, -2.728486f12, 8.346593f12  …  1.8842418f13, 5.178649f12, -7.665734f12, 1.285762f13, 1.0423372f13, 1.1724157f13, -1.2031495f12, -2.1124363f13, 2.3137939f13, -1.0284885f12]</code></pre><p>Notice that the solution values <code>sol[i]</code> are CUDA-based arrays, which can be moved back to the CPU using <code>Array(sol[i])</code>.</p><p>More details on effective use of within-method GPU parallelism can be found in <a href="../tutorials/within_method_gpu/#withingpu">the within-method GPU parallelism tutorial</a>.</p><h2 id="Example-of-Parameter-Parallelism-with-GPU-Ensemble-Methods"><a class="docs-heading-anchor" href="#Example-of-Parameter-Parallelism-with-GPU-Ensemble-Methods">Example of Parameter-Parallelism with GPU Ensemble Methods</a><a id="Example-of-Parameter-Parallelism-with-GPU-Ensemble-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Example-of-Parameter-Parallelism-with-GPU-Ensemble-Methods" title="Permalink"></a></h2><p>On the other side of the spectrum, what if we want to solve tons of small ODEs? For this use case, we would use the ensemble methods to solve the same ODE many times with different parameters. This looks like:</p><pre><code class="language-julia hljs">using DiffEqGPU, OrdinaryDiffEq, StaticArrays, CUDA

function lorenz(u, p, t)
    σ = p[1]
    ρ = p[2]
    β = p[3]
    du1 = σ * (u[2] - u[1])
    du2 = u[1] * (ρ - u[3]) - u[2]
    du3 = u[1] * u[2] - β * u[3]
    return SVector{3}(du1, du2, du3)
end

u0 = @SVector [1.0f0; 0.0f0; 0.0f0]
tspan = (0.0f0, 10.0f0)
p = @SVector [10.0f0, 28.0f0, 8 / 3.0f0]
prob = ODEProblem{false}(lorenz, u0, tspan, p)
prob_func = (prob, i, repeat) -&gt; remake(prob, p = (@SVector rand(Float32, 3)) .* p)
monteprob = EnsembleProblem(prob, prob_func = prob_func, safetycopy = false)

sol = solve(monteprob, GPUTsit5(), EnsembleGPUKernel(CUDA.CUDABackend()),
    trajectories = 10_000)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">EnsembleSolution Solution of length 10000 with uType:
SciMLBase.ODESolution{Float32, 2, SubArray{StaticArraysCore.SVector{3, Float32}, 1, Matrix{StaticArraysCore.SVector{3, Float32}}, Tuple{UnitRange{Int64}, Int64}, true}, Nothing, Nothing, SubArray{Float32, 1, Matrix{Float32}, Tuple{UnitRange{Int64}, Int64}, true}, Nothing, DiffEqGPU.ImmutableODEProblem{StaticArraysCore.SVector{3, Float32}, Tuple{Float32, Float32}, false, StaticArraysCore.SVector{3, Float32}, SciMLBase.ODEFunction{false, SciMLBase.AutoSpecialize, typeof(Main.lorenz), LinearAlgebra.UniformScaling{Bool}, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, typeof(SciMLBase.DEFAULT_OBSERVED), Nothing, Nothing}, Base.Pairs{Symbol, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}, SciMLBase.StandardODEProblem}, GPUTsit5, SciMLBase.LinearInterpolation{SubArray{Float32, 1, Matrix{Float32}, Tuple{UnitRange{Int64}, Int64}, true}, SubArray{StaticArraysCore.SVector{3, Float32}, 1, Matrix{StaticArraysCore.SVector{3, Float32}}, Tuple{UnitRange{Int64}, Int64}, true}}, Nothing, Nothing}</code></pre><p>To dig more into this example, see the <a href="../tutorials/gpu_ensemble_basic/#lorenz">ensemble GPU solving tutorial</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« DiffEqGPU: Massively Data-Parallel GPU Solving of ODEs</a><a class="docs-footer-nextpage" href="../tutorials/gpu_ensemble_basic/">Massively Data-Parallel ODE Solving the Lorenz Equation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.2 on <span class="colophon-date" title="Saturday 11 November 2023 17:20">Saturday 11 November 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
